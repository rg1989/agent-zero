---
phase: 11-tmux-primitive-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - docker/run/fs/ins/copy_A0.sh
autonomous: false
gap_closure: true
requirements: [TERM-01, TERM-02, TERM-03, TERM-04]

must_haves:
  truths:
    - "After a container restart, the agent knows about TmuxTool send/keys/read actions without a volume wipe"
    - "Changes to python/tools/ and prompts/ on the host are reflected inside the container without rebuilding"
    - "copy_A0.sh copies new/updated files from the image even when /a0 is already populated"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Bind mounts for python/ and prompts/ directories"
      contains: "./python:/a0/python"
    - path: "docker/run/fs/ins/copy_A0.sh"
      provides: "Correct copy logic that updates existing /a0 contents"
  key_links:
    - from: "docker-compose.yml"
      to: "/a0/python/tools/tmux_tool.py"
      via: "volume bind mount ./python:/a0/python"
      pattern: "./python:/a0/python"
    - from: "docker-compose.yml"
      to: "/a0/prompts/agent.system.tool.tmux.md"
      via: "volume bind mount ./prompts:/a0/prompts"
      pattern: "./prompts:/a0/prompts"
---

<objective>
Fix the stale Docker volume deployment gap that prevented TmuxTool and its prompt documentation from reaching /a0 inside the container.

Purpose: Phase 11-01 created python/tools/tmux_tool.py and prompts/agent.system.tool.tmux.md correctly, but UAT revealed the agent never saw them. Root cause: copy_A0.sh skips copying when /a0 is already populated from the persistent volume, and python/ and prompts/ have no bind mounts as a live-reload path. This plan fixes both issues structurally so all future tool and prompt changes deploy automatically.

Output: docker-compose.yml with python/ and prompts/ bind mounts; copy_A0.sh that copies updated files regardless of /a0 population state; verified agent awareness of TmuxTool.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-tmux-primitive-infrastructure/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add python/ and prompts/ bind mounts to docker-compose.yml and fix copy_A0.sh</name>
  <files>docker-compose.yml, docker/run/fs/ins/copy_A0.sh</files>
  <action>
**docker-compose.yml** — Add two bind mounts to the `volumes:` list under the `agent-zero` service, after the existing `./apps:/a0/apps` entry:

```yaml
      - ./python:/a0/python   # live-reload: tool changes reach container without rebuild
      - ./prompts:/a0/prompts # live-reload: prompt doc changes reach container without rebuild
```

Final volumes block (replace existing, preserve existing two lines plus the named volume):

```yaml
    volumes:
      - agent-zero-data:/per
      - ./webui:/a0/webui     # live-reload: host webui/ is served directly
      - ./apps:/a0/apps       # persist built web apps across rebuilds
      - ./python:/a0/python   # live-reload: tool changes reach container without rebuild
      - ./prompts:/a0/prompts # live-reload: prompt doc changes reach container without rebuild
```

**docker/run/fs/ins/copy_A0.sh** — Replace the presence-check guard with a `cp -ru` (recursive, update-only — copies if source is newer). The new script copies all files from the image snapshot into /a0 on every container start, but only overwrites when the source is newer. This means bind-mounted paths (webui, apps, python, prompts) will be overridden by the volume mounts declared in docker-compose.yml, so the cp call is safe even with bind mounts present.

Replace the entire script body with:

```bash
#!/bin/bash
set -e

# Paths
SOURCE_DIR="/git/agent-zero"
TARGET_DIR="/a0"

# Copy repository files from image to /a0, updating files newer in the image.
# Bind mounts declared in docker-compose.yml (webui/, apps/, python/, prompts/)
# shadow the copied files at runtime — this ensures non-mounted paths (e.g.,
# run_ui.py, requirements.txt) are always up to date from the image.
echo "Syncing files from $SOURCE_DIR to $TARGET_DIR (update-newer)..."
cp -ru --no-preserve=ownership,mode "$SOURCE_DIR/." "$TARGET_DIR"
```

The key change: remove the `if [ ! -f run_ui.py ]` guard and replace `cp -rn` (no-clobber) with `cp -ru` (update-newer). The `-u` flag only overwrites target files that are older than the source, which is correct: image files baked at build time are always "newer" than stale volume contents from a prior run.
  </action>
  <verify>
Confirm both files are changed correctly:

```bash
grep "python:/a0/python" /Users/rgv250cc/Documents/Projects/agent-zero/docker-compose.yml && echo "python mount: OK"
grep "prompts:/a0/prompts" /Users/rgv250cc/Documents/Projects/agent-zero/docker-compose.yml && echo "prompts mount: OK"
grep "cp -ru" /Users/rgv250cc/Documents/Projects/agent-zero/docker/run/fs/ins/copy_A0.sh && echo "copy_A0.sh: OK"
grep -v "if \[ ! -f" /Users/rgv250cc/Documents/Projects/agent-zero/docker/run/fs/ins/copy_A0.sh | grep -v "fi" && echo "guard removed: OK"
```
  </verify>
  <done>docker-compose.yml contains both new bind mount lines; copy_A0.sh uses `cp -ru` with no presence-check guard.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Bind mounts added to docker-compose.yml; copy_A0.sh updated to sync-newer on every start. The container must now be restarted (or volume wiped + rebuilt if this is the first time) to validate the fix.</what-built>
  <how-to-verify>
**Step 1 — Rebuild and restart the container.**

If the persistent volume was already populated before this fix (which the UAT confirmed), you MUST clear it once so copy_A0.sh can sync the new files:

```bash
cd /Users/rgv250cc/Documents/Projects/agent-zero
docker compose down
docker volume rm agent-zero_agent-zero-data
docker compose up --build -d
```

After the build, tail logs briefly to confirm startup:

```bash
docker compose logs -f agent-zero | head -60
```

Look for: "Syncing files from /git/agent-zero to /a0 (update-newer)..." in the early log lines (this confirms copy_A0.sh ran with the new logic).

**Step 2 — Confirm tmux_tool.py and the prompt file are visible inside the container.**

```bash
docker exec agent-zero ls /a0/python/tools/tmux_tool.py
docker exec agent-zero ls /a0/prompts/agent.system.tool.tmux.md
```

Both commands should return the file path (no "No such file" error).

**Step 3 — Verify agent awareness of TmuxTool.**

Open the Agent Zero web UI at http://localhost:50000. Start a new chat. Ask:

> "What tmux tool actions do you have available?"

Expected: The agent describes `send`, `keys`, and `read` actions — NOT just `terminal_agent` capabilities. It should mention pane targeting and the distinction between send (text + Enter) and keys (special key names).

**Step 4 — Quick functional smoke test.**

In the same chat, ask the agent to:

> "Use TmuxTool send to run `echo hello-from-tmux` in the shared terminal."

Expected: The command executes in the shared terminal pane (visible in the terminal panel). The agent does not reply "I don't have a tool called TmuxTool".
  </how-to-verify>
  <resume-signal>Type "approved" if all four steps pass, or describe which step failed and what you saw.</resume-signal>
</task>

</tasks>

<verification>
Infrastructure gap is closed when:
- docker-compose.yml has bind mounts for both python/ and prompts/
- copy_A0.sh uses cp -ru (sync-newer, no presence guard)
- Container restart brings python/tools/tmux_tool.py and prompts/agent.system.tool.tmux.md into /a0
- Agent describes TmuxTool send/keys/read actions when asked
- Agent can execute a TmuxTool send call without "I don't have a tool" error
</verification>

<success_criteria>
- Agent knows about TmuxTool send/keys/read actions (UAT test 1 passes)
- TmuxTool send executes a command in the shared terminal (UAT test 2 passes)
- Future changes to python/tools/ and prompts/ on the host are live inside the container without a rebuild
- copy_A0.sh no longer silently skips new image files when /a0 is populated
</success_criteria>

<output>
After completion, create `.planning/phases/11-tmux-primitive-infrastructure/11-02-SUMMARY.md` following the standard summary template. Mark requirements TERM-01, TERM-02, TERM-03, TERM-04 as completed (they were already completed by 11-01; this plan resolves the deployment gap that prevented verification).
</output>
