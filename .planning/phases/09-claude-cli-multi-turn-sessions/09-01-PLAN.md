---
phase: 09-claude-cli-multi-turn-sessions
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - python/helpers/claude_cli.py
autonomous: true
requirements: [CLAUDE-04]

must_haves:
  truths:
    - "Agent Zero can send two or more prompts in sequence and each response reflects memory of prior turns (session continuity confirmed)"
    - "Each turn returns a complete, non-truncated response within the timeout period — no partial output, no ANSI artifacts, no JSON wrapper visible to the caller"
    - "Agent Zero detects a dead/expired session (returncode 1 + 'No conversation found') and restarts cleanly rather than hanging"
    - "ClaudeSession class tracks session_id automatically so callers never manage UUIDs manually"
  artifacts:
    - path: "python/helpers/claude_cli.py"
      provides: "claude_turn(), ClaudeSession, claude_turn_with_recovery() added to existing file"
      min_lines: 180
      exports: ["claude_turn", "ClaudeSession", "claude_turn_with_recovery"]
  key_links:
    - from: "ClaudeSession.turn()"
      to: "claude_turn()"
      via: "delegates turn execution, stores returned session_id"
      pattern: "self\\._session_id.*=.*claude_turn"
    - from: "claude_turn()"
      to: "subprocess.run"
      via: "--resume session_id flag when session_id is not None"
      pattern: "'--resume'.*session_id"
    - from: "claude_turn_with_recovery()"
      to: "claude_turn()"
      via: "catches RuntimeError containing 'No conversation found', retries with session_id=None"
      pattern: "No conversation found"
---

<objective>
Extend python/helpers/claude_cli.py with multi-turn session support: claude_turn() function, ClaudeSession class, and claude_turn_with_recovery() helper.

Purpose: Phase 8 established single-turn invocation. Phase 9 adds the --resume UUID mechanism that chains subprocess.run calls into a conversation with memory. No new infrastructure — same subprocess.run + capture_output=True + env_clean pattern, one extra flag (--resume), one extra return value (session_id).

Output: claude_cli.py gains three new exports (claude_turn, ClaudeSession, claude_turn_with_recovery). End-to-end validated against live claude binary: 3-turn conversation with memory confirmed, dead-session detection confirmed.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-claude-cli-multi-turn-sessions/09-RESEARCH.md
@.planning/phases/08-claude-cli-single-turn-env-fix/08-01-SUMMARY.md
@python/helpers/claude_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-turn functions to claude_cli.py</name>
  <files>python/helpers/claude_cli.py</files>
  <action>
Append three new exports to python/helpers/claude_cli.py. Do NOT modify the existing claude_single_turn() or claude_single_turn_text() functions — append below them.

**1. claude_turn(prompt, session_id=None, model=None, timeout=CLAUDE_DEFAULT_TIMEOUT) -> tuple[str, str]**

Executes one turn of a multi-turn claude conversation. Returns (response_text, session_id).

Implementation:
- Build env_clean the same way as existing functions: `{k: v for k, v in os.environ.items() if k != 'CLAUDECODE'}`
- Build cmd: `['claude', '--print', '--output-format', 'json']`
- If model is provided: append `['--model', model]`
- If session_id is provided: append `['--resume', session_id]` — this is the ONLY difference from single-turn
- Append prompt to cmd
- Call subprocess.run(cmd, capture_output=True, text=True, env=env_clean, timeout=timeout)
- Handle TimeoutExpired: raise RuntimeError(f"claude turn timed out after {timeout}s")
- Handle FileNotFoundError: raise RuntimeError("claude binary not found in PATH")
- On returncode != 0: extract err = (result.stderr.strip() or result.stdout.strip())[:400]; raise RuntimeError(f"claude exited {result.returncode}: {err}")
- Strip ANSI: stdout_clean = ANSI_RE.sub('', result.stdout).strip()
- Parse JSON: data = json.loads(stdout_clean)
- Check is_error: if data.get('is_error'): raise RuntimeError(f"claude API error: {data.get('result', 'unknown')}")
- Return (data['result'], data['session_id'])

Docstring must explain:
- Returns tuple (response_text, session_id) — session_id must be passed to next call as --resume
- Dead session: returncode 1 + "No conversation found with session ID:" in stderr; raises RuntimeError
- session_id=None starts a new session; session_id from prior turn continues the conversation

**2. ClaudeSession class**

Stateful wrapper that tracks session_id automatically. Fields: _session_id=None, _model=None, _timeout=CLAUDE_DEFAULT_TIMEOUT.

Methods:
- `__init__(self, model=None, timeout=CLAUDE_DEFAULT_TIMEOUT)`: set self._session_id = None, self._model = model, self._timeout = timeout
- `turn(self, prompt: str) -> str`: calls `response, self._session_id = claude_turn(prompt, session_id=self._session_id, model=self._model, timeout=self._timeout)`, returns response
- `reset(self)`: sets self._session_id = None (next turn starts fresh session)
- `session_id` property: returns self._session_id (read-only)

**3. claude_turn_with_recovery(prompt, session_id=None, timeout=CLAUDE_DEFAULT_TIMEOUT) -> tuple[str, str, bool]**

Wraps claude_turn() with automatic dead-session recovery. Returns (response_text, new_session_id, was_recovered).

Implementation:
- Try: `response, new_sid = claude_turn(prompt, session_id=session_id, timeout=timeout); return response, new_sid, False`
- Except RuntimeError as e: if session_id and 'No conversation found' in str(e): restart with `response, new_sid = claude_turn(prompt, session_id=None, timeout=timeout); return response, new_sid, True`
- Otherwise: re-raise

Docstring must explain:
- was_recovered=True means session was dead and a fresh session was started (conversation context is lost)
- was_recovered=False means existing session was continued normally
- Always use --resume UUID over --continue to avoid cwd race conditions when multiple sessions are active

Add a module-level comment block before the new functions noting:
```
# ---------------------------------------------------------------------------
# Multi-turn session support (Phase 9)
# ---------------------------------------------------------------------------
# Extends single-turn helpers above with --resume UUID support.
# Implementation: same subprocess.run + capture_output=True pattern as Phase 8.
# New flag: --resume session_id (appended to cmd when session_id is not None).
# Completion signal: process returncode (unambiguous; no idle-timeout needed).
# ---------------------------------------------------------------------------
```
  </action>
  <verify>
Run: `python3 -c "from python.helpers.claude_cli import claude_turn, ClaudeSession, claude_turn_with_recovery; print('imports OK')"` from /Users/rgv250cc/Documents/Projects/agent-zero

Also verify file structure:
- `python3 -c "import inspect; from python.helpers import claude_cli; print([n for n,_ in inspect.getmembers(claude_cli) if not n.startswith('_')])"` — must include claude_turn, ClaudeSession, claude_turn_with_recovery, claude_single_turn, claude_single_turn_text

Also static-check: grep -n 'def claude_turn\|class ClaudeSession\|def claude_turn_with_recovery' python/helpers/claude_cli.py — must show all three.
  </verify>
  <done>
python/helpers/claude_cli.py contains claude_turn(), ClaudeSession class, and claude_turn_with_recovery() beneath the existing single-turn functions. All three import cleanly. The file is syntactically valid (no import errors). Existing claude_single_turn() and claude_single_turn_text() are unmodified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate multi-turn against live claude binary</name>
  <files>python/helpers/claude_cli.py</files>
  <action>
Write a validation script to /tmp/test_multi_turn_09.py and run it via nohup (same technique as Phase 8, since Anthropic API calls take 30-60s and the Bash tool times out on long-running interactive processes). Verify all three behaviors:

**Test A — 3-turn conversation with memory (ClaudeSession)**
```python
import sys
sys.path.insert(0, '/Users/rgv250cc/Documents/Projects/agent-zero')
from python.helpers.claude_cli import ClaudeSession

session = ClaudeSession()
r1 = session.turn("My secret number is 42. Reply: GOT_IT")
assert r1.strip() == 'GOT_IT' or 'GOT_IT' in r1, f"T1 fail: {r1!r}"
sid1 = session.session_id
assert sid1 is not None, "session_id must be set after turn 1"

r2 = session.turn("What is my secret number?")
assert '42' in r2, f"T2 memory fail: {r2!r}"
sid2 = session.session_id
assert sid2 == sid1, f"session_id changed: {sid1} -> {sid2}"

r3 = session.turn("Double that number and give me just the result as an integer.")
assert '84' in r3, f"T3 memory fail: {r3!r}"
print(f"PASS A — 3-turn memory: r1={r1!r} r2={r2!r} r3={r3!r} sid={sid1}")
```

**Test B — dead session detection (claude_turn_with_recovery)**
```python
from python.helpers.claude_cli import claude_turn_with_recovery

FAKE_UUID = '00000000-0000-0000-0000-000000000000'
resp, new_sid, was_recovered = claude_turn_with_recovery(
    "Reply: RECOVERED", session_id=FAKE_UUID
)
assert was_recovered is True, f"was_recovered should be True, got {was_recovered}"
assert 'RECOVERED' in resp, f"response wrong: {resp!r}"
assert new_sid != FAKE_UUID, "new_sid must be a fresh UUID"
print(f"PASS B — dead session recovery: was_recovered={was_recovered}, new_sid={new_sid}")
```

**Test C — reset() starts fresh session**
```python
from python.helpers.claude_cli import ClaudeSession

s = ClaudeSession()
_ = s.turn("Remember: zebra")
old_sid = s.session_id
s.reset()
assert s.session_id is None, "session_id must be None after reset()"
_ = s.turn("Reply: NEW")
new_sid = s.session_id
assert new_sid != old_sid, f"reset must produce new session: {old_sid} == {new_sid}"
print(f"PASS C — reset: old={old_sid} new={new_sid}")
```

Write all three tests to /tmp/test_multi_turn_09.py with a final `print("ALL TESTS PASSED")` at the end.

Run with: `nohup python3 /tmp/test_multi_turn_09.py > /tmp/test_multi_turn_09.out 2>&1 &` then `sleep 5 && echo "launched"`.

Poll for completion: Every 30s, run `cat /tmp/test_multi_turn_09.out` until "ALL TESTS PASSED" or an error/traceback appears. Allow up to 5 minutes total (API calls take 30-60s each; 3 tests × ~3 turns = ~9 API calls).

If any test fails: diagnose from output and fix claude_cli.py, then re-run.
  </action>
  <verify>
cat /tmp/test_multi_turn_09.out must contain:
- "PASS A — 3-turn memory"
- "PASS B — dead session recovery"
- "PASS C — reset"
- "ALL TESTS PASSED"

No tracebacks or assertion errors in the output.
  </verify>
  <done>
All three tests pass against the live claude binary:
- 3-turn conversation shows session memory (turn 2 recalls secret number, turn 3 doubles it)
- Dead session detection: returncode 1 + "No conversation found" triggers recovery, was_recovered=True returned
- reset() clears session_id, next turn gets a fresh UUID different from the old one
  </done>
</task>

</tasks>

<verification>
1. `grep -c 'def claude_turn\|class ClaudeSession\|def claude_turn_with_recovery' /Users/rgv250cc/Documents/Projects/agent-zero/python/helpers/claude_cli.py` — must return 3
2. `python3 -c "from python.helpers.claude_cli import claude_turn, ClaudeSession, claude_turn_with_recovery"` from project root — no ImportError
3. cat /tmp/test_multi_turn_09.out — must show all three PASS lines and "ALL TESTS PASSED"
4. `grep -c 'claude_single_turn\|claude_single_turn_text' /Users/rgv250cc/Documents/Projects/agent-zero/python/helpers/claude_cli.py` — must return >= 2 (original functions untouched)
</verification>

<success_criteria>
- python/helpers/claude_cli.py exports claude_turn(), ClaudeSession, claude_turn_with_recovery()
- claude_turn() extends Phase 8 pattern: same subprocess.run, same env_clean, adds --resume flag and returns (text, session_id) tuple
- ClaudeSession.turn() chains turns automatically — callers never touch session_id directly
- claude_turn_with_recovery() catches dead-session RuntimeError and restarts with session_id=None, returns was_recovered=True
- Live validation confirms 3-turn conversation memory, dead-session recovery, and reset() behavior
- CLAUDE-04 requirement fully satisfied: multi-turn conversation with session continuity, clean response per turn, dead session detection and recovery
</success_criteria>

<output>
After completion, create .planning/phases/09-claude-cli-multi-turn-sessions/09-01-SUMMARY.md
</output>
