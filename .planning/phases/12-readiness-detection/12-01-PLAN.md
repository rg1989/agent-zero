---
phase: 12-readiness-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/tools/tmux_tool.py
  - prompts/agent.system.tool.tmux.md
autonomous: true
requirements:
  - TERM-05

must_haves:
  truths:
    - "wait_ready called after send does not return until pane prompt appears or timeout expires — never injects input mid-command"
    - "ANSI escape sequences (color, cursor, OSC title) are stripped from capture-pane output before any pattern matching"
    - "When a shell prompt ($ # > %) appears on the last non-blank line, wait_ready returns promptly without waiting the full timeout"
    - "When no prompt appears within the configured timeout (default 10s), wait_ready returns with a timeout message rather than hanging indefinitely"
    - "CLI sub-prompts like 'Continue? [y/N]' (ending with ]) do NOT trigger a false ready signal with the default prompt pattern"
  artifacts:
    - path: "python/tools/tmux_tool.py"
      provides: "_wait_ready() method with dual-strategy detection; 'wait_ready' registered in dispatch dict"
      contains: "_wait_ready"
    - path: "prompts/agent.system.tool.tmux.md"
      provides: "wait_ready action documented with usage examples, timeout note, and prompt_pattern override"
      contains: "wait_ready"
  key_links:
    - from: "TmuxTool.execute()"
      to: "TmuxTool._wait_ready()"
      via: "dispatch dict entry 'wait_ready'"
      pattern: "\"wait_ready\".*_wait_ready"
    - from: "_wait_ready()"
      to: "ANSI_RE.sub()"
      via: "applied to capture-pane output before prompt matching"
      pattern: "ANSI_RE\\.sub.*result\\.stdout"
    - from: "_wait_ready() prompt check"
      to: "last non-blank line only"
      via: "lines = [l for l in clean.splitlines() if l.strip()]"
      pattern: "lines\\[-1\\]"
---

<objective>
Add `wait_ready` action to TmuxTool: poll the tmux pane every 0.5s, strip ANSI, detect either a shell prompt on the last non-blank line (primary) or content stability (secondary), and return when either fires or the timeout expires.

Purpose: Prevents blind injection — agent cannot send the next command while a prior command is still running. This is the gating primitive that all CLI orchestration in Phases 13–15 depends on.
Output: Updated tmux_tool.py with _wait_ready() + updated agent prompt doc with wait_ready usage.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-readiness-detection/12-RESEARCH.md
@python/tools/tmux_tool.py
@prompts/agent.system.tool.tmux.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _wait_ready() method and dispatch entry to TmuxTool</name>
  <files>python/tools/tmux_tool.py</files>
  <action>
Add `import asyncio` and `import time` to the existing imports at the top of the file (after `import subprocess` and `import re` — they are not currently imported).

Add `_wait_ready` to the dispatch dict in `execute()`:
```python
dispatch = {"send": self._send, "keys": self._keys, "read": self._read, "wait_ready": self._wait_ready}
```
Update the error message for unknown actions to include `wait_ready` in the valid list.

Add the `_wait_ready()` async method to the TmuxTool class after `_read()`. Use the exact implementation from 12-RESEARCH.md (complete wait_ready implementation code block). Key implementation rules:

1. Args: `pane` (default `_TMUX_SESSION`), `timeout` (float, default `10.0`), `prompt_pattern` (str, default `r"[$#>%]\s*$"`)
2. Compile the regex before the loop; return a clear error Response if `re.compile` raises `re.error`
3. `deadline = time.time() + timeout` for hard cutoff
4. `prev_content = None` — stability check skipped on the first iteration (only compare when `prev_content is not None`)
5. `await asyncio.sleep(0.3)` BEFORE the first capture (initial delay — allows the shell to consume Enter and start executing; prevents stale-prompt false positive)
6. Loop `while time.time() < deadline:`, each iteration:
   a. `subprocess.run(["tmux", "capture-pane", "-t", pane, "-p", "-S", "-50"], capture_output=True, text=True)` — note `-S -50` (not `-S -100`; 50 lines is enough for prompt detection and faster in a tight poll loop)
   b. If returncode != 0: return error Response immediately
   c. `clean = ANSI_RE.sub("", result.stdout).rstrip()` — always strip ANSI before any matching
   d. Strategy 1 (PRIMARY): `lines = [l for l in clean.splitlines() if l.strip()]` — then `if lines and prompt_re.search(lines[-1])` — match ONLY the last non-blank line, never against history
   e. Strategy 2 (SECONDARY): `if prev_content is not None and clean == prev_content` — stability
   f. Both: `return Response(message=f"ready (prompt matched)\n{clean}", break_loop=False)` or `"ready (stable)\n{clean}"` respectively
   g. `prev_content = clean`
   h. `await asyncio.sleep(0.5)`
7. After loop (timeout path): do a final `subprocess.run` capture and return `Response(message=f"wait_ready timed out after {timeout}s\n{content}", break_loop=False)`

Do NOT use: `tmux wait-for`, `monitor-silence`, sentinel injection, pexpect, libtmux. Do NOT match against full scrollback — only `lines[-1]`.
  </action>
  <verify>
Run: `python3 -c "import python.tools.tmux_tool as m; import inspect; src = inspect.getsource(m.TmuxTool); assert '_wait_ready' in src; assert 'asyncio' in src; assert 'time.time' in src; print('OK')"` from the project root.

Also check dispatch: `python3 -c "import ast, sys; tree = ast.parse(open('python/tools/tmux_tool.py').read()); print('syntax OK')"`.
  </verify>
  <done>
tmux_tool.py has no syntax errors, imports asyncio and time, dispatch includes 'wait_ready', and _wait_ready() method exists with: initial 0.3s sleep, ANSI strip via ANSI_RE, last-non-blank-line prompt match, stability check (skipped on first iteration), and timeout fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update agent prompt doc with wait_ready action and usage examples</name>
  <files>prompts/agent.system.tool.tmux.md</files>
  <action>
Update `prompts/agent.system.tool.tmux.md` to add `wait_ready` action documentation. Changes:

1. In the `action` argument line, add `wait_ready` to the pipe-separated list:
   `* \`action\` (string, required) — \`send\` | \`keys\` | \`read\` | \`wait_ready\``

2. Add new arguments for wait_ready (after the `lines` argument):
   ```
   * `timeout` (number, optional) — for `wait_ready`: seconds before giving up (default: 10). Use 120 when waiting on AI CLI responses.
   * `prompt_pattern` (string, optional) — for `wait_ready`: regex anchored to line-end (default: `"[$#>%]\\s*$"` — matches bash/zsh/sh/node prompts). Override for non-standard shells.
   ```

3. Add a `wait_ready` behavioral note block after the existing `!!!` lines:
   ```
   !!! Always call `wait_ready` after `send` before injecting the next input
   !!! Default timeout is 10s — use timeout: 120 when waiting for AI CLI responses (OpenCode, claude)
   !!! `wait_ready` returns current pane content in its response (same as `read`)
   !!! prompt_pattern matches last non-blank line only — sub-prompts like "Continue? [y/N]" do NOT trigger ready
   ```

4. Add three usage examples at the end of the document (after the existing `read` example):
   ```markdown
   #### Usage: wait for terminal to be ready after sending a command
   ```json
   { "tool_name": "tmux_tool", "tool_args": { "action": "wait_ready" } }
   ```

   #### Usage: wait with longer timeout (for AI CLI tools that take 30-120s)
   ```json
   { "tool_name": "tmux_tool", "tool_args": { "action": "wait_ready", "timeout": 120 } }
   ```

   #### Usage: wait with custom prompt pattern (for non-standard CLI prompts)
   ```json
   { "tool_name": "tmux_tool", "tool_args": { "action": "wait_ready", "prompt_pattern": "opencode> $" } }
   ```
   ```

Do NOT add redundant checkpoint boilerplate. Keep the doc concise — the existing style uses `!!!` warnings and `#### Usage:` examples, continue that pattern.
  </action>
  <verify>
Run: `grep -c "wait_ready" prompts/agent.system.tool.tmux.md` — must return at least 6 (action list, 2 arg docs, 4 !!! lines, 3 example blocks).
  </verify>
  <done>
prompts/agent.system.tool.tmux.md lists wait_ready in the action argument, documents timeout and prompt_pattern arguments, includes 4 behavioral !!! warnings, and has 3 usage examples.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate implementation with a live test against the shared terminal</name>
  <files></files>
  <action>
Run a functional validation test to confirm wait_ready works end-to-end. Execute from the project root inside Docker (or directly if tmux is running locally):

**Step 1 — Verify module loads clean:**
```bash
python3 -c "from python.tools.tmux_tool import TmuxTool, ANSI_RE; import asyncio, time; print('imports OK')"
```

**Step 2 — Verify ANSI stripping on sample escape sequences:**
```bash
python3 -c "
from python.tools.tmux_tool import ANSI_RE
import re
# Bash colored prompt: \e[32m$ \e[0m
sample = '\x1b[32m\$ \x1b[0m'
clean = ANSI_RE.sub('', sample)
assert clean.strip() == '\$', f'Got: {repr(clean)}'
# OSC title sequence
osc_sample = '\x1b]0;user@host\x07\$ '
clean2 = ANSI_RE.sub('', osc_sample)
assert '\$' in clean2 or clean2.strip().endswith('\$') or clean2.strip() == '\$', f'OSC not stripped: {repr(clean2)}'
print('ANSI strip: OK')
"
```

**Step 3 — Verify default prompt pattern matches shell prompts and rejects sub-prompts:**
```bash
python3 -c "
import re
pat = re.compile(r'[\$#>%]\s*\$')
# Must match
assert pat.search('user@host:~\$ '), 'bash prompt not matched'
assert pat.search('# '), 'root prompt not matched'
assert pat.search('> '), 'node REPL not matched'
# Must NOT match
assert not pat.search('Continue? [y/N]'), 'sub-prompt false positive!'
assert not pat.search('Are you sure? (y/n)'), 'confirm false positive!'
print('prompt pattern: OK')
"
```

**Step 4 — If shared terminal is running (Docker or local tmux), run a live wait_ready call:**
```bash
python3 -c "
import asyncio
# Minimal standalone test without full Agent Zero bootstrap — only if tmux session 'shared' exists
import subprocess
r = subprocess.run(['tmux', 'list-sessions'], capture_output=True, text=True)
if 'shared' not in r.stdout:
    print('SKIP: shared tmux session not running — live test skipped')
else:
    print('LIVE: shared session found — manual verification available via agent')
"
```

If the live test is skipped (shared session not running locally), note this in the summary. The live verification is best done through the actual agent using the tool after deployment. Document any skip reason in the SUMMARY.
  </action>
  <verify>
Steps 1-3 must all print OK. Step 4 either confirms live session or skips gracefully. No Python exceptions or import errors.
  </verify>
  <done>
Module imports cleanly, ANSI stripping works on colored prompts and OSC sequences, default prompt pattern matches shell prompts and rejects [y/N] sub-prompts. Live test either passes or is documented as deferred to Docker deployment validation.
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import ast; ast.parse(open('python/tools/tmux_tool.py').read()); print('syntax OK')"` — no errors
2. `grep "wait_ready" python/tools/tmux_tool.py | wc -l` — at least 3 lines (dispatch entry, method def, docstring)
3. `grep "asyncio" python/tools/tmux_tool.py` — import present
4. `grep "time.time" python/tools/tmux_tool.py` — deadline pattern present
5. `grep "ANSI_RE.sub" python/tools/tmux_tool.py | wc -l` — at least 2 (one in _read, one in _wait_ready)
6. `grep "lines\[-1\]" python/tools/tmux_tool.py` — last-non-blank-line guard present
7. `grep "wait_ready" prompts/agent.system.tool.tmux.md | wc -l` — at least 6
8. `grep "timeout" prompts/agent.system.tool.tmux.md` — timeout argument documented
</verification>

<success_criteria>
- TmuxTool accepts `action: "wait_ready"` and dispatches to `_wait_ready()`
- `_wait_ready()` polls every 0.5s with an initial 0.3s delay
- ANSI stripping via existing ANSI_RE applied before every prompt check
- Prompt check targets ONLY the last non-blank line (prevents scrollback false positives)
- Default pattern `[$#>%]\s*$` matches bash/zsh/sh/node prompts; does NOT match `Continue? [y/N]`
- Stability fallback fires when two consecutive captures return identical content
- Timeout (default 10s) triggers a return with current pane content — never hangs indefinitely
- `timeout` and `prompt_pattern` are agent-configurable arguments
- Agent prompt doc updated: action list, argument docs, !!! warnings, 3 usage examples
- TERM-05 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/12-readiness-detection/12-01-SUMMARY.md` using the standard summary template.
</output>
