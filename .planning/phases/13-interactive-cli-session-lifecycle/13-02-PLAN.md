---
phase: 13-interactive-cli-session-lifecycle
plan: 02
type: execute
wave: 2
depends_on: [13-01]
files_modified:
  - docker/run/fs/ins/install_additional.sh
  - python/tools/tmux_tool.py
  - prompts/agent.system.tool.tmux.md
autonomous: false
requirements: [CLI-01, CLI-02, CLI-03, CLI-04]

must_haves:
  truths:
    - "Agent Zero can start OpenCode TUI in the shared terminal and wait_ready returns 'ready (prompt matched)' using the empirically verified prompt_pattern from Plan 13-01"
    - "Agent Zero can send a multi-turn prompt sequence to a running OpenCode session, with each response captured after wait_ready detects the ready state"
    - "Agent Zero can exit OpenCode cleanly with /exit and wait_ready on the default shell pattern confirms the terminal returns to a normal shell prompt"
    - "OpenCode binary is installed permanently in the Docker image via install_additional.sh (survives container rebuilds)"
    - "tmux_tool.py exposes OPENCODE_PROMPT_PATTERN constant (from 13-01 findings) so Phase 14 can import it without re-hardcoding"
    - "prompts/agent.system.tool.tmux.md documents the OpenCode lifecycle pattern for agent self-use"
  artifacts:
    - path: "docker/run/fs/ins/install_additional.sh"
      provides: "OpenCode permanent installation in Docker image"
      contains: "opencode"
    - path: "python/tools/tmux_tool.py"
      provides: "OPENCODE_PROMPT_PATTERN constant and _OPENCODE_START_TIMEOUT constant for Phase 14 reuse"
      contains: "OPENCODE_PROMPT_PATTERN"
    - path: "prompts/agent.system.tool.tmux.md"
      provides: "OpenCode lifecycle usage example for agent"
      contains: "opencode"
  key_links:
    - from: "python/tools/tmux_tool.py"
      to: "OPENCODE_PROMPT_PATTERN"
      via: "module-level constant exported for Phase 14 import"
      pattern: "OPENCODE_PROMPT_PATTERN"
    - from: "prompts/agent.system.tool.tmux.md"
      to: "CLI lifecycle steps"
      via: "documented example of start → wait_ready → send → wait_ready → /exit → wait_ready"
      pattern: "opencode"
    - from: "docker/run/fs/ins/install_additional.sh"
      to: "OpenCode binary"
      via: "curl -fsSL https://opencode.ai/install | bash"
      pattern: "opencode.ai/install"
---

<objective>
Implement CLI-01 through CLI-04 using the empirically verified prompt patterns from Plan 13-01, making OpenCode session lifecycle fully operational in the shared terminal.

Purpose: Phase 13's research (13-01) established ground truth about OpenCode TUI behavior. This plan encodes that ground truth into the codebase: a module-level constant in tmux_tool.py, permanent Docker installation, and agent prompt documentation — giving Phase 14 a clean, verified foundation for the OpenCodeSession wrapper.

Output: Working CLI-01..04 lifecycle validated end-to-end; OPENCODE_PROMPT_PATTERN constant exportable by Phase 14; OpenCode installed permanently in Docker image.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-interactive-cli-session-lifecycle/13-RESEARCH.md
@.planning/phases/13-interactive-cli-session-lifecycle/13-01-OBSERVATION.md
@.planning/phases/12-readiness-detection/12-01-SUMMARY.md
@python/tools/tmux_tool.py
@prompts/agent.system.tool.tmux.md
@docker/run/fs/ins/install_additional.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OpenCode permanent install to install_additional.sh and constants to tmux_tool.py</name>
  <files>
    docker/run/fs/ins/install_additional.sh
    python/tools/tmux_tool.py
  </files>
  <action>
    **Part A: install_additional.sh**

    Read 13-01-OBSERVATION.md `## Version` section to get the confirmed version string. Add an OpenCode installation block to `docker/run/fs/ins/install_additional.sh` AFTER the shared-terminal block (after the ttyd install, before the noVNC block). Use the official install script pattern established in RESEARCH.md:

    ```bash
    # ── OpenCode CLI ──────────────────────────────────────────────────────────
    echo "Installing OpenCode CLI..."
    curl -fsSL https://opencode.ai/install | bash
    echo 'export PATH=/root/.opencode/bin:$PATH' >> /root/.bashrc
    echo "OpenCode installed ($(/root/.opencode/bin/opencode --version 2>&1 || echo 'version unknown'))."
    ```

    Place this block at the correct insertion point (after tmux/ttyd section, before noVNC section).

    **Part B: tmux_tool.py**

    Read 13-01-OBSERVATION.md `## Final Recommendations for Plan 13-02` section. Extract:
    - The confirmed `prompt_pattern` regex string
    - The startup timeout value

    Add two module-level constants to `python/tools/tmux_tool.py` immediately after the `ANSI_RE` line (line ~11). Use the EXACT pattern from 13-01-OBSERVATION.md — do NOT invent a pattern:

    ```python
    # OpenCode TUI ready-state prompt pattern — empirically verified in Phase 13 (13-01-OBSERVATION.md)
    # Use this with: tmux_tool(action="wait_ready", prompt_pattern=OPENCODE_PROMPT_PATTERN, timeout=120)
    OPENCODE_PROMPT_PATTERN = r"[PATTERN_FROM_OBSERVATION_MD]"

    # Timeout for OpenCode TUI startup (seconds) — observed startup time + 2x safety margin
    OPENCODE_START_TIMEOUT = [TIMEOUT_FROM_OBSERVATION_MD]  # seconds
    ```

    Replace `[PATTERN_FROM_OBSERVATION_MD]` with the actual pattern string from OBSERVATION.md.
    Replace `[TIMEOUT_FROM_OBSERVATION_MD]` with the actual numeric value from OBSERVATION.md.

    IMPORTANT: If OBSERVATION.md shows that no distinct prompt pattern was found (e.g., OpenCode TUI ready state is indistinguishable from busy state after ANSI stripping), set:
    ```python
    OPENCODE_PROMPT_PATTERN = None  # No reliable pattern found — use stability fallback only
    OPENCODE_START_TIMEOUT = 30  # seconds
    ```
    And document this as a finding in the SUMMARY.md for Phase 14 to account for.
  </action>
  <verify>
    1. `grep -n "opencode.ai/install" docker/run/fs/ins/install_additional.sh` — returns the install line
    2. `grep -n "OPENCODE_PROMPT_PATTERN" python/tools/tmux_tool.py` — returns the constant definition
    3. `grep -n "OPENCODE_START_TIMEOUT" python/tools/tmux_tool.py` — returns the constant definition
    4. Python AST check: `python3 -c "import ast; ast.parse(open('python/tools/tmux_tool.py').read()); print('syntax ok')"` — returns "syntax ok"
    5. `grep -A3 "OPENCODE_PROMPT_PATTERN" python/tools/tmux_tool.py` shows the pattern matches what is in 13-01-OBSERVATION.md
  </verify>
  <done>
    install_additional.sh contains OpenCode install block; tmux_tool.py has OPENCODE_PROMPT_PATTERN and OPENCODE_START_TIMEOUT constants sourced from 13-01-OBSERVATION.md; syntax valid.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update agent prompt doc and validate CLI-01..04 lifecycle end-to-end</name>
  <files>
    prompts/agent.system.tool.tmux.md
  </files>
  <action>
    **Part A: Update prompts/agent.system.tool.tmux.md**

    Read the current `prompts/agent.system.tool.tmux.md`. Add a new section titled `## OpenCode Lifecycle Pattern` after the existing usage examples. This section documents the empirically verified 4-step lifecycle (CLI-01..04) as a ready-to-copy usage pattern for the agent:

    ```markdown
    ## OpenCode Lifecycle Pattern

    Use these exact tmux_tool calls to orchestrate an OpenCode session.
    All patterns verified empirically in Phase 13 (see 13-01-OBSERVATION.md).

    ### CLI-01: Start OpenCode and wait for ready state
    ```json
    {"action": "send", "text": "opencode /a0"}
    {"action": "wait_ready", "timeout": [OPENCODE_START_TIMEOUT], "prompt_pattern": "[OPENCODE_PROMPT_PATTERN]"}
    ```

    ### CLI-02 + CLI-03: Send prompt, wait for response, read result
    ```json
    {"action": "send", "text": "Your prompt here"}
    {"action": "wait_ready", "timeout": 120, "prompt_pattern": "[OPENCODE_PROMPT_PATTERN]"}
    {"action": "read", "lines": 300}
    ```

    ### CLI-04: Exit cleanly
    ```json
    {"action": "send", "text": "/exit"}
    {"action": "wait_ready", "timeout": 15}
    ```
    !!! After /exit, wait_ready uses the default shell prompt pattern — OpenCode pattern is NOT needed here.
    !!! Verify shell prompt is restored by checking the read output for $ or # prompt.

    ### Multi-turn loop
    Repeat CLI-02+CLI-03 steps for each prompt. Each send/wait_ready/read cycle is one turn.
    OpenCode maintains session context automatically within the TUI process.
    ```

    Replace `[OPENCODE_START_TIMEOUT]` and `[OPENCODE_PROMPT_PATTERN]` with the actual values from 13-01-OBSERVATION.md. If OPENCODE_PROMPT_PATTERN is None (no pattern found), omit the `"prompt_pattern"` key from CLI-02/03 examples and add a note that stability fallback is used.

    **Part B: End-to-end lifecycle validation**

    Execute the full CLI-01..04 lifecycle via the Docker container to confirm it works:

    ```bash
    # Ensure PATH is set in the shared tmux pane
    docker exec agent-zero bash -c "tmux send-keys -t shared 'export PATH=/root/.opencode/bin:\$PATH' Enter"
    sleep 1

    # CLI-01: Start OpenCode
    docker exec agent-zero bash -c "tmux send-keys -t shared 'opencode /a0' Enter"
    sleep [OPENCODE_START_TIMEOUT]  # use observed startup time

    # Capture and verify ready state
    docker exec agent-zero bash -c "
      tmux capture-pane -t shared -p -S -50 |
      python3 -c \"
import sys, re
ANSI_RE = re.compile(r'\x1b(?:\][^\x07]*\x07|[@-Z\\\\\\\\-_]|\[[0-?]*[ -/]*[@-~])')
clean = ANSI_RE.sub('', sys.stdin.read()).rstrip()
lines = [l for l in clean.splitlines() if l.strip()]
print('READY CHECK — last non-blank:', repr(lines[-1]) if lines else '(empty)')
import re as re2
pat = r'[OPENCODE_PROMPT_PATTERN]'
print('Pattern match:', bool(re2.search(pat, lines[-1])) if lines else False)
\""

    # CLI-02+CLI-03: Send prompt, wait for response
    docker exec agent-zero bash -c "tmux send-keys -t shared 'What is /a0? Reply in one sentence.' Enter"
    sleep 30  # wait for AI response (Ollama must be running on host)

    # Capture response
    docker exec agent-zero bash -c "tmux capture-pane -t shared -p -S -100"

    # CLI-04: Exit
    docker exec agent-zero bash -c "tmux send-keys -t shared '/exit' Enter"
    sleep 5
    docker exec agent-zero bash -c "tmux capture-pane -t shared -p -S -20"
    # Output must show shell prompt ($ or # character), not OpenCode TUI
    ```

    Record the validation results in the plan summary. The lifecycle is validated when:
    1. Ready state capture shows prompt_pattern match = True after startup
    2. Response is visible in capture after sending a prompt
    3. Shell prompt (not TUI) is visible after /exit

    If Ollama is not running during validation, CLI-02/03 can be validated by sending `/help` (a non-LLM TUI command) or simply verifying that the TUI accepts input — document that LLM path was not tested and the reason.
  </action>
  <verify>
    1. `grep -n "OpenCode Lifecycle Pattern" prompts/agent.system.tool.tmux.md` — section exists
    2. `grep "OPENCODE_PROMPT_PATTERN\|opencode_prompt\|prompt_pattern" prompts/agent.system.tool.tmux.md` — pattern value documented in prompt doc
    3. End-to-end validation: startup → ready state captured → prompt accepted → /exit → shell prompt returned
    4. No Python syntax errors in tmux_tool.py after modifications
    5. `docker exec agent-zero bash -c "export PATH=/root/.opencode/bin:\$PATH && opencode --version"` — still works after all changes
  </verify>
  <done>
    prompts/agent.system.tool.tmux.md has OpenCode lifecycle section with concrete tmux_tool call examples.
    End-to-end CLI-01..04 lifecycle executed successfully in the shared terminal:
    - CLI-01: OpenCode started, wait_ready returned "ready (prompt matched)" or "ready (stable)"
    - CLI-02+03: Prompt sent and response captured (or /help verified if Ollama unavailable)
    - CLI-04: /exit sent, shell prompt confirmed in pane
    All four requirements (CLI-01, CLI-02, CLI-03, CLI-04) are satisfied with empirically verified implementation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verify — CLI-01..04 lifecycle in shared terminal</name>
  <what-built>
    Full CLI-01..04 lifecycle implemented and tested:
    - OPENCODE_PROMPT_PATTERN constant in tmux_tool.py (sourced from empirical observation)
    - OPENCODE_START_TIMEOUT constant in tmux_tool.py
    - OpenCode permanent install in install_additional.sh
    - OpenCode lifecycle pattern documented in prompts/agent.system.tool.tmux.md
    - End-to-end validation executed: start → send → response → exit
  </what-built>
  <how-to-verify>
    1. Open the shared terminal at http://localhost:50000 in your browser
    2. Confirm the shell prompt is visible (not OpenCode TUI) — prior validation left the terminal clean
    3. In the browser terminal, run: `export PATH=/root/.opencode/bin:$PATH && opencode --version`
       - Expected: version string like `1.2.5`
    4. Run: `opencode /a0` — the TUI should appear within ~5s
    5. When ready, type a short question and press Enter; wait for a response
    6. Type `/exit` — the TUI should close and the shell prompt should return
    7. Check `python/tools/tmux_tool.py` lines 10-20 — confirm OPENCODE_PROMPT_PATTERN and OPENCODE_START_TIMEOUT are present
    8. Check `docker/run/fs/ins/install_additional.sh` — confirm OpenCode install block is present
  </how-to-verify>
  <resume-signal>Type "approved" if the lifecycle works end-to-end, or describe any issues (e.g., "TUI not rendering", "exit hangs", "pattern mismatch")</resume-signal>
  <action>Human verifies the complete CLI-01..04 lifecycle in the shared terminal browser UI at http://localhost:50000. Follow the how-to-verify steps above.</action>
  <verify>User types "approved" or describes issues found during manual verification.</verify>
  <done>User has confirmed OpenCode starts, accepts input, returns a response, and exits cleanly — all four requirements (CLI-01..04) visually verified in the shared terminal.</done>
</task>

</tasks>

<verification>
1. `grep -n "OPENCODE_PROMPT_PATTERN" python/tools/tmux_tool.py` returns pattern constant
2. `grep -n "OPENCODE_START_TIMEOUT" python/tools/tmux_tool.py` returns timeout constant
3. `grep -n "opencode.ai/install" docker/run/fs/ins/install_additional.sh` returns install line
4. `grep -n "OpenCode Lifecycle Pattern" prompts/agent.system.tool.tmux.md` returns section header
5. `python3 -c "import ast; ast.parse(open('python/tools/tmux_tool.py').read()); print('ok')"` — syntax valid
6. Human verification confirms end-to-end CLI-01..04 lifecycle works in shared terminal
</verification>

<success_criteria>
- OPENCODE_PROMPT_PATTERN and OPENCODE_START_TIMEOUT constants in tmux_tool.py with values sourced from 13-01-OBSERVATION.md
- install_additional.sh installs OpenCode on Docker image rebuild (permanent, not just runtime)
- prompts/agent.system.tool.tmux.md documents the complete OpenCode lifecycle pattern
- CLI-01 verified: OpenCode starts, wait_ready detects ready state
- CLI-02+03 verified: prompt sent, response captured after wait_ready
- CLI-04 verified: /exit returns shell prompt cleanly
- Human has visually confirmed the flow in the browser terminal
</success_criteria>

<output>
After completion, create `.planning/phases/13-interactive-cli-session-lifecycle/13-02-SUMMARY.md`
</output>
