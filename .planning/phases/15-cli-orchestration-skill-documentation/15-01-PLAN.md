---
phase: 15-cli-orchestration-skill-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - usr/skills/cli-orchestration/SKILL.md
autonomous: true
requirements:
  - CLI-06

must_haves:
  truths:
    - "usr/skills/cli-orchestration/SKILL.md exists and documents all four tmux_tool actions (send, keys, read, wait_ready) with correct JSON invocation syntax"
    - "The skill includes the execution context isolation warning: code_execution_tool and the shared tmux session are separate, non-sharing execution contexts"
    - "The Read-Detect-Write-Verify cycle is documented as the required interaction pattern with numbered steps and a complete JSON example"
    - "OpenCode-specific patterns are documented: OPENCODE_PROMPT_PATTERN (both branches), startup sequence with 0.5s pause, Ctrl+P exit sequence, and all empirical timeout values"
    - "OpenCodeSession Python API is documented with correct import path, lifecycle methods (.start()/.send()/.exit()), and return-value description"
    - "The skill follows the established claude-cli/SKILL.md format: metadata block, DEFAULT rule, stack table, pattern sections, decision guide, pitfalls table, troubleshooting table"
  artifacts:
    - path: "usr/skills/cli-orchestration/SKILL.md"
      provides: "Self-contained CLI orchestration skill — tmux primitives through OpenCode lifecycle"
      min_lines: 200
      contains: "DEFAULT CLI ORCHESTRATION RULE"
    - path: "usr/skills/cli-orchestration/SKILL.md"
      provides: "tmux_tool action reference"
      contains: "tmux_tool"
    - path: "usr/skills/cli-orchestration/SKILL.md"
      provides: "OpenCode prompt pattern"
      contains: "OPENCODE_PROMPT_PATTERN"
    - path: "usr/skills/cli-orchestration/SKILL.md"
      provides: "Execution context isolation warning"
      contains: "code_execution_tool"
  key_links:
    - from: "usr/skills/cli-orchestration/SKILL.md"
      to: "python/helpers/opencode_cli.py"
      via: "import path documented in skill"
      pattern: "from python.helpers.opencode_cli import OpenCodeSession"
    - from: "usr/skills/cli-orchestration/SKILL.md"
      to: "python/tools/tmux_tool.py"
      via: "action reference documented with JSON invocation syntax"
      pattern: "tool_name.*tmux_tool"
---

<objective>
Create usr/skills/cli-orchestration/SKILL.md — a self-contained skill document that captures every validated CLI orchestration pattern from Phases 11-14 so any Agent Zero session can orchestrate interactive CLI tools (specifically OpenCode) without re-discovering these patterns.

Purpose: Satisfies CLI-06. Phase 13 empirical findings + Phase 14 OpenCodeSession patterns are encoded months of testing — an agent reading only this skill must be able to orchestrate correctly without consulting implementation files.
Output: usr/skills/cli-orchestration/SKILL.md (new directory + file)
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-cli-orchestration-skill-documentation/15-RESEARCH.md

# Format model — follow this structure exactly
@usr/skills/claude-cli/SKILL.md

# Source implementations — draw all content from these verified files
@python/tools/tmux_tool.py
@python/helpers/opencode_cli.py
@prompts/agent.system.tool.tmux.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usr/skills/cli-orchestration/SKILL.md</name>
  <files>usr/skills/cli-orchestration/SKILL.md</files>
  <action>
Create the directory usr/skills/cli-orchestration/ and write SKILL.md following the format of usr/skills/claude-cli/SKILL.md exactly. Do NOT create any other files (no AGENTS.md, no rules/ directory).

The skill must be self-contained — an agent reading only this file can orchestrate any interactive CLI and specifically OpenCode without consulting implementation files.

Required sections in order:

**1. Metadata block**
- name: cli-orchestration
- version: 1.0
- description: Orchestrate interactive CLI tools (OpenCode, REPLs, any interactive process) via the shared tmux session using tmux_tool actions
- tags: [tmux, cli, opencode, interactive, terminal, orchestration]
- author: agent-zero

**2. Overview**
One paragraph. State that python/tools/tmux_tool.py provides the primitive interface and python/helpers/opencode_cli.py provides the high-level OpenCodeSession wrapper. This skill documents both layers and the patterns connecting them.

**3. DEFAULT CLI ORCHESTRATION RULE**
State when to load: any task that requires starting an interactive CLI (OpenCode, a REPL, any process that needs input/output after launch) in the shared terminal, OR any task that uses tmux_tool directly.

**4. Stack table**
Four rows:
| tmux_tool | python/tools/tmux_tool.py | Primitive interface: send, keys, read, wait_ready |
| OpenCodeSession | python/helpers/opencode_cli.py | High-level wrapper: .start()/.send()/.exit() — hides tmux plumbing |
| OpenCode TUI | v1.2.14 at /root/.opencode/bin/opencode | Interactive CLI being orchestrated |
| tmux session | named "shared" | Shared terminal visible to user at /shared-terminal/ |

**5. CRITICAL: Execution Context Isolation**
Use a code block to state the rule clearly:
  - code_execution_tool (runtime="python" or runtime="bash") spawns isolated subshells/PTYs NOT connected to the shared tmux session
  - Processes started in code_execution_tool are NOT visible in the shared terminal
  - Processes running in the shared tmux session are NOT accessible to code_execution_tool
  - TTYSession (python/helpers/tty_session.py) is explicitly BANNED for shared terminal use — it creates an isolated PTY subprocess, not connected to the shared session
  - CORRECT approach: use tmux_tool (sends commands to the tmux binary which routes to the named "shared" session)
  - Warning signs that you violated this: commands run but shared terminal is unchanged; pane reads return unexpected content

**6. tmux_tool Action Reference**
Document all four actions with copy-paste JSON invocation blocks. Source: python/tools/tmux_tool.py

`send` action (TERM-01):
  - JSON: {"tool_name": "tmux_tool", "tool_args": {"action": "send", "text": "ls -la"}}
  - text is passed as a single literal string — tmux does NOT interpret words like "Tab" as key names
  - "Enter" is added automatically
  - Use for: running commands, submitting prompts, typing file paths

`keys` action (TERM-02/TERM-03):
  - JSON: {"tool_name": "tmux_tool", "tool_args": {"action": "keys", "keys": "C-c"}}
  - keys is space-separated tmux key names
  - Key name reference: C-c (interrupt), C-d (EOF/exit), C-p (commands palette), Tab (completion), BTab (reverse tab), Escape, Enter, Up, Down, Left, Right, BSpace, PPage, NPage
  - Can be a list: ["C-p", "Enter"]
  - Use for: Ctrl+C to interrupt, Tab completion, y/n inline prompts, special sequences

`read` action (TERM-04):
  - JSON: {"tool_name": "tmux_tool", "tool_args": {"action": "read", "lines": 100}}
  - lines (optional, default 100): scrollback lines to capture
  - Returns ANSI-stripped plain text of pane content
  - Use for: observing terminal state before or after actions

`wait_ready` action (TERM-05):
  - JSON: {"tool_name": "tmux_tool", "tool_args": {"action": "wait_ready", "timeout": 10, "prompt_pattern": "[$#>%]\\s*$"}}
  - timeout (optional, default 10s): use 120 for AI CLI responses (OpenCode, claude)
  - prompt_pattern (optional, default "[$#>%]\\s*$"): regex matched against last non-blank ANSI-stripped line
  - Two detection strategies: (1) prompt pattern match on last non-blank line (primary), (2) content stability — pane stopped changing (secondary)
  - Initial 0.3s delay before first capture prevents stale-prompt false positive
  - Returns current pane content when ready state detected

**7. The Read-Detect-Write-Verify Cycle**
State this is the required interaction pattern for ALL interactive CLI orchestration. Analogous to Observe-Act-Verify in the browser skill.

Steps:
1. Read — capture current pane state before acting (wait_ready or read)
2. Detect — confirm the CLI is at the expected ready state (prompt pattern matched)
3. Write — send input (send for text+Enter, keys for special keys)
4. Verify — wait for response completion (wait_ready with appropriate timeout and prompt_pattern), then read to confirm

Why ordering matters (include all three failure modes):
- Skip "Read" → you may send input to the wrong state (CLI still processing previous input)
- Skip "Detect" → you may send input before the CLI is ready, causing lost input or double-submission
- Skip "Verify" → you may read partial output or proceed before response is complete

Include the generic CLI session JSON example from the RESEARCH.md (python3 -i REPL example).

**8. OpenCode-Specific Patterns**
Header note: "All values empirically verified: 2026-02-25, OpenCode v1.2.14, Docker aarch64."

**OPENCODE_PROMPT_PATTERN** — include the full regex and explain both branches:
```
r'^(?:\s*/a0\s+\d+\.\d+\.\d+\s*$|(?!.*esc interrupt).*ctrl\+t variants\s+tab agents)'
```
Branch 1 (startup): matches TUI status bar at bottom-right showing project path + version (e.g., `  /a0  ...  1.2.14`)
Branch 2 (post-response): matches hints bar after any LLM response, WITHOUT "esc interrupt" busy-state indicator
Busy state: when "esc interrupt" appears in last non-blank line — NEITHER branch matches — wait_ready keeps polling (correct behavior)

**Startup Sequence** — 3 steps with JSON:
1. send: "export PATH=/root/.opencode/bin:$PATH && opencode /a0" (PATH export is defensive no-op if already set)
2. Wait 0.5s (sleep in surrounding code — TUI input widget activation time)
3. wait_ready with timeout: 15 and OPENCODE_PROMPT_PATTERN

**Timeout Values** — table:
| CLI-01 startup wait_ready | 15s | Observed startup ~1.5s; 10x buffer |
| CLI-02/03 response wait_ready | 120s | AI response budget for real models |
| CLI-04 exit wait_ready | 15s | Shell return observed in 1-2s; 10x buffer |

**CRITICAL — Exit Sequence** (use a CRITICAL callout):
DO NOT use {"action": "send", "text": "/exit"}. In OpenCode v1.2.14, the "/" character typed into the TUI input area immediately opens the AGENT PICKER. "exit" then goes into the agent search box — TUI stays open, shell never returns.

Verified 3-step exit sequence:
```json
// Step 1: Open commands palette
{"tool_name": "tmux_tool", "tool_args": {"action": "keys", "keys": "C-p"}}
// Step 2: Wait 0.2s for palette, then filter + execute
{"tool_name": "tmux_tool", "tool_args": {"action": "send", "text": "exit"}}
// Step 3: Wait for shell prompt
{"tool_name": "tmux_tool", "tool_args": {"action": "wait_ready", "timeout": 15}}
```
"exit" filters palette to "Exit the app" and Enter executes it. OpenCode exits in 1-2s.

**First-Ever-Start Behaviors** (non-blocking, awareness only):
- DB migration on FIRST ever start in fresh container — takes <3s, does not recur
- "Getting started" dialog after FIRST LLM response — overlays right panel but does NOT block input, ignore for automated use

**Session Resumption** (informational):
At exit, OpenCode prints: "Continue  opencode -s ses_[SESSION_ID]". Resume with: send "opencode -s ses_[SESSION_ID] /a0"

**Complete raw tmux_tool example** — include the full JSON example from RESEARCH.md (CLI-01 + CLI-02+03 + CLI-04).

**9. Using OpenCodeSession (Recommended)**
State this is the recommended approach — hides all tmux plumbing, encodes all empirically verified patterns.

Import:
```python
import sys
sys.path.insert(0, '/a0')
from python.helpers.opencode_cli import OpenCodeSession
```

Lifecycle:
```python
session = OpenCodeSession()
session.start()                                      # starts TUI, waits for ready state (~1.5s)
r1 = session.send("What does /a0/python/tools/tmux_tool.py do?")
r2 = session.send("How many actions does TmuxTool implement?")
session.exit()                                        # Ctrl+P palette exit, waits for shell prompt
```

Document each method:
- `OpenCodeSession(response_timeout=120)`: instantiate; response_timeout adjustable for slow models
- `start()`: sends start command, sleeps 0.5s, waits for OPENCODE_PROMPT_PATTERN; raises RuntimeError if not ready within 15s
- `send(prompt) -> str`: types prompt + Enter, waits for OPENCODE_PROMPT_PATTERN, returns full 300-line ANSI-stripped pane content (TUI chrome included; assistant response visible within content)
- `exit()`: Ctrl+P palette exit sequence, waits for shell prompt; idempotent (no-op if not running)
- `session.running`: bool property — True after start(), False after exit()

**Response extraction note**: send() returns full pane content (300 lines) including TUI chrome. The assistant response is visible in the returned content. Enhancement: capture pane before send, capture after wait_ready, diff to isolate new content — not required for v1 usage.

**10. Decision Guide**
| Need | Use |
| Start OpenCode, send prompts, exit cleanly | OpenCodeSession (recommended) |
| Run a shell command in shared terminal | tmux_tool send action |
| Send Ctrl+C / interrupt a running process | tmux_tool keys action: "C-c" |
| Check current terminal state | tmux_tool read action |
| Wait for a non-OpenCode CLI to be ready | tmux_tool wait_ready with tool-specific prompt_pattern |
| Orchestrate any interactive REPL (python3 -i, node, etc.) | tmux_tool send + wait_ready with custom prompt_pattern |
| OpenCode multi-turn conversation | OpenCodeSession multi-turn (TUI context persists between send() calls) |
| Need isolated subprocess (not shared terminal) | code_execution_tool — but NOT for shared terminal interaction |

**11. Common Pitfalls**
Table format (same as claude-cli/SKILL.md):

| Pitfall | Fix |
| Using code_execution_tool to interact with shared terminal | Use tmux_tool — code_execution_tool spawns isolated contexts; they never share state with the shared tmux session |
| Sending /exit to OpenCode | Use 3-step Ctrl+P palette sequence or OpenCodeSession.exit() — / opens agent picker in v1.2.14 |
| Using default 10s timeout for AI responses | Use timeout: 120 for OpenCode/claude responses — default 10s is for shell commands only |
| Missing 0.5s sleep before first wait_ready after OpenCode start | Use OpenCodeSession.start() which encodes this delay; for raw tmux_tool usage, add sleep(0.5) before wait_ready |
| Writing a new ANSI regex instead of using ANSI_RE | Copy ANSI_RE exactly from tmux_tool.py — OSC branch (\][^\x07]*\x07) MUST come before 2-char branch ([@-Z\\-_]) because ] (0x5D) falls in \-_ range |
| Default prompt_pattern [$#>%]\s*$ false-positive on sub-prompts | For OpenCode, use OPENCODE_PROMPT_PATTERN; for other tools, write a specific enough pattern to exclude sub-prompts |
| TTYSession for shared terminal | TTYSession creates isolated PTY subprocess — NOT connected to shared session; use tmux_tool exclusively |

**12. Troubleshooting**
| Problem | Fix |
| After "exit" attempt, TUI still shows agent picker / build native / plan native | / triggered agent picker instead of command — press Escape, then use Ctrl+P palette sequence |
| wait_ready times out on AI response | Increase timeout to 120s+; verify Ollama is running at host:11434 and model is loaded |
| pane read returns empty or unexpected content | Confirm tmux session "shared" exists: run `tmux ls` in code_execution_tool |
| Commands run in code_execution_tool but shared terminal unchanged | You are using wrong execution context — switch to tmux_tool for shared terminal interaction |
| OpenCodeSession.start() raises RuntimeError timeout | Check OpenCode binary exists at /root/.opencode/bin/opencode; check Ollama connectivity |
| send() returns TUI chrome with no recognizable response | Response was likely cut off by timeout — increase response_timeout in OpenCodeSession constructor |
| First start shows DB migration text before TUI | Normal first-ever-start behavior — wait_ready with 15s timeout handles this; does not recur |
  </action>
  <verify>
    1. File exists: ls usr/skills/cli-orchestration/SKILL.md
    2. Contains required sections: grep -c "DEFAULT CLI ORCHESTRATION RULE\|Read-Detect-Write-Verify\|OPENCODE_PROMPT_PATTERN\|Execution Context Isolation\|OpenCodeSession\|Decision Guide\|Common Pitfalls\|Troubleshooting" usr/skills/cli-orchestration/SKILL.md
    3. Line count is substantial: wc -l usr/skills/cli-orchestration/SKILL.md (expect 200+ lines)
    4. Import path is correct: grep "from python.helpers.opencode_cli import OpenCodeSession" usr/skills/cli-orchestration/SKILL.md
    5. Exit regression warning present: grep "agent picker\|AGENT PICKER\|C-p\|Ctrl+P" usr/skills/cli-orchestration/SKILL.md
    6. No other files created: ls usr/skills/cli-orchestration/ (only SKILL.md)
  </verify>
  <done>
    usr/skills/cli-orchestration/SKILL.md exists with 200+ lines covering all required sections. All 6 grep checks pass. CLI-06 requirement satisfied: an agent reading only this file can orchestrate any interactive CLI and specifically OpenCode without consulting implementation files.
  </done>
</task>

</tasks>

<verification>
After task completion, confirm CLI-06 is satisfied:
1. `grep -c "tmux_tool\|wait_ready\|send\|read\|keys" usr/skills/cli-orchestration/SKILL.md` — action reference is present
2. `grep "code_execution_tool" usr/skills/cli-orchestration/SKILL.md` — isolation warning is present
3. `grep "Read-Detect-Write-Verify" usr/skills/cli-orchestration/SKILL.md` — cycle documented
4. `grep "ctrl+t variants\|OPENCODE_PROMPT_PATTERN" usr/skills/cli-orchestration/SKILL.md` — OpenCode patterns present
5. `grep "claude-cli\|SKILL.md" usr/skills/cli-orchestration/SKILL.md` — format follows established pattern
</verification>

<success_criteria>
- usr/skills/cli-orchestration/SKILL.md exists and is self-contained
- All four tmux_tool actions documented with correct JSON invocation syntax
- Execution context isolation warning present and unambiguous
- Read-Detect-Write-Verify cycle documented with numbered steps and JSON example
- OpenCode prompt pattern (OPENCODE_PROMPT_PATTERN) documented with both branches explained
- Ctrl+P exit sequence documented with /exit regression warning
- OpenCodeSession import path and all three lifecycle methods documented
- Decision guide covers when to use each tool/pattern
- Common pitfalls and troubleshooting tables complete
- CLI-06 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/15-cli-orchestration-skill-documentation/15-01-SUMMARY.md`
</output>
