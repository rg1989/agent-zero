---
phase: 08-claude-cli-single-turn-env-fix
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - python/helpers/claude_cli.py
autonomous: true
requirements:
  - CLAUDE-01
  - CLAUDE-02
  - CLAUDE-03

must_haves:
  truths:
    - "Running claude subprocess from Agent Zero Python context with CLAUDECODE set does NOT produce 'Cannot be launched inside another Claude Code session' error"
    - "claude_single_turn('test prompt') returns a non-empty string containing only the response text — no ANSI escape sequences, no JSON wrapper"
    - "Process exit is detected cleanly: returncode == 0 on success, RuntimeError raised with stderr on non-zero exit"
    - "Calling claude_single_turn() with a bad prompt or timeout raises RuntimeError with a diagnostic message, not a silent hang or unhandled exception"
  artifacts:
    - path: "python/helpers/claude_cli.py"
      provides: "claude_single_turn() and claude_single_turn_text() functions"
      min_lines: 40
      contains: "CLAUDECODE"
  key_links:
    - from: "python/helpers/claude_cli.py"
      to: "claude binary"
      via: "subprocess.run with env_clean dict"
      pattern: "env_clean.*CLAUDECODE"
    - from: "subprocess.run capture_output=True"
      to: "json.loads result.stdout"
      via: "ANSI_RE.sub safety strip then json.loads"
      pattern: "json\\.loads"
---

<objective>
Create the Python helper module that implements the validated claude CLI single-turn invocation pattern: env fix, subprocess capture, JSON parsing, ANSI stripping, and error handling — then verify it works end-to-end from the host Python environment.

Purpose: Satisfies CLAUDE-01/02/03 by making a reusable, importable function that Agent Zero can use from its Python runtime (`code_execution_tool` with `runtime="python"`) to call claude as a subprocess.

Output: `python/helpers/claude_cli.py` with `claude_single_turn()` and `claude_single_turn_text()` functions, validated by a live test run against the actual claude binary.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-claude-cli-single-turn-env-fix/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create python/helpers/claude_cli.py with validated single-turn pattern</name>
  <files>python/helpers/claude_cli.py</files>
  <action>
Create `python/helpers/claude_cli.py` implementing the two single-turn invocation functions from the empirically verified research (08-RESEARCH.md, HIGH confidence, all patterns confirmed 2026-02-25 on claude 2.1.55).

**CRITICAL: Never modify os.environ globally. Build env_clean as a per-call dict only.**

File structure:

```python
"""
claude_cli.py — Claude CLI single-turn invocation helper.

Implements Agent Zero's validated pattern for calling the claude CLI
from within a Claude Code session (CLAUDECODE env fix) or any Python
subprocess context.

Empirically verified: 2026-02-25, claude 2.1.55
"""
import subprocess
import os
import json
import re

# ANSI escape sequence pattern — safety net for capture_output=True path.
# When subprocess runs with capture_output=True (not a TTY), claude outputs
# zero ANSI. This strip is defensive only.
# Pattern covers: ESC[@-Z\-_] (2-char) and ESC[...final (CSI sequences)
ANSI_RE = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")

CLAUDE_DEFAULT_TIMEOUT = 120  # seconds; claude API typically responds in 2-30s


def claude_single_turn(prompt: str, model: str = None, timeout: int = CLAUDE_DEFAULT_TIMEOUT) -> str:
    """
    Call claude CLI in single-turn (--print) mode. Returns clean response text.

    Uses --output-format json to get structured response; extracts .result field.
    CLAUDECODE is removed from subprocess env only — os.environ is never modified.

    Args:
        prompt: The user prompt string.
        model: Optional model override (e.g., 'haiku', 'sonnet', 'opus').
                If None, uses claude's default (claude-sonnet-4-5).
        timeout: Max seconds to wait for response. Default 120s.

    Returns:
        str: Clean response text, no ANSI sequences, no JSON wrapper.

    Raises:
        RuntimeError: If claude exits non-zero, returns is_error=True,
                      binary not found, or subprocess.TimeoutExpired.
        json.JSONDecodeError: If --output-format json response is malformed.
    """
    # Remove CLAUDECODE from subprocess env only — NEVER del os.environ['CLAUDECODE']
    # or os.unsetenv(). Those affect the whole process. Dict comprehension is scoped
    # to this call only.
    env_clean = {k: v for k, v in os.environ.items() if k != 'CLAUDECODE'}

    cmd = ['claude', '--print', '--output-format', 'json']
    if model:
        cmd += ['--model', model]
    cmd.append(prompt)

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            env=env_clean,
            timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        raise RuntimeError(
            f"claude single-turn timed out after {timeout}s. "
            "Increase timeout or check API connectivity."
        )
    except FileNotFoundError:
        raise RuntimeError(
            "claude binary not found in PATH. "
            "Verify: shutil.which('claude') or check ~/.local/bin is on PATH."
        )

    if result.returncode != 0:
        err = (result.stderr.strip() or result.stdout.strip())[:400]
        raise RuntimeError(f"claude exited {result.returncode}: {err}")

    # Safety strip (no-op when capture_output=True, but handles edge cases)
    stdout_clean = ANSI_RE.sub('', result.stdout).strip()

    data = json.loads(stdout_clean)

    if data.get('is_error'):
        raise RuntimeError(f"claude API error: {data.get('result', 'unknown error')}")

    return data['result']  # Clean response text


def claude_single_turn_text(prompt: str, model: str = None, timeout: int = CLAUDE_DEFAULT_TIMEOUT) -> str:
    """
    Call claude CLI in single-turn mode, returning plain text output.

    Uses --output-format text (no JSON wrapper). Simpler than claude_single_turn()
    when metadata (cost, session_id, usage) is not needed.

    Args:
        prompt: The user prompt string.
        model: Optional model override.
        timeout: Max seconds to wait. Default 120s.

    Returns:
        str: Clean response text.

    Raises:
        RuntimeError: If claude exits non-zero, binary not found, or timeout.
    """
    env_clean = {k: v for k, v in os.environ.items() if k != 'CLAUDECODE'}

    cmd = ['claude', '--print', '--output-format', 'text']
    if model:
        cmd += ['--model', model]
    cmd.append(prompt)

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            env=env_clean,
            timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        raise RuntimeError(f"claude single-turn-text timed out after {timeout}s")
    except FileNotFoundError:
        raise RuntimeError("claude binary not found in PATH")

    if result.returncode != 0:
        err = (result.stderr.strip() or result.stdout.strip())[:400]
        raise RuntimeError(f"claude exited {result.returncode}: {err}")

    return ANSI_RE.sub('', result.stdout).strip()
```

**Notes for implementation:**
- The ANSI_RE pattern is from `shell_ssh.py` — same regex, already battle-tested in codebase
- `capture_output=True` sets stdout/stderr as PIPE and prevents TTY attachment — this is what gives clean output (no OSC sequences)
- `text=True` decodes stdout/stderr as UTF-8 str (not bytes) — simplifies downstream usage
- Do NOT use `subprocess.DEVNULL` for stderr — we need stderr for error diagnosis
- `shutil` import is NOT needed unless adding a PATH check utility — keep imports minimal
- The `claude` binary path: empirically confirmed at `~/.local/bin/claude` on host. The PATH in Agent Zero's subprocess env inherits from os.environ, which should include `~/.local/bin`. If PATH issues arise, caller can use full path as `cmd[0]`.
  </action>
  <verify>
Run in the project directory:
```bash
cd /Users/rgv250cc/Documents/Projects/agent-zero && python3 -c "
import python.helpers.claude_cli as cc
import inspect
print('Functions:', [n for n in dir(cc) if not n.startswith('_')])
src = inspect.getsource(cc)
assert 'CLAUDECODE' in src, 'CLAUDECODE env fix missing'
assert 'capture_output=True' in src, 'capture_output=True missing'
assert 'json.loads' in src, 'JSON parsing missing'
assert 'is_error' in src, 'error check missing'
print('STRUCTURE OK')
"
```
  </verify>
  <done>
`python/helpers/claude_cli.py` exists with `claude_single_turn()` and `claude_single_turn_text()` functions. Structure check passes: CLAUDECODE env fix present, capture_output=True present, json.loads present, is_error check present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate single-turn pattern end-to-end against live claude binary</name>
  <files>python/helpers/claude_cli.py</files>
  <action>
Run a live end-to-end validation of `claude_single_turn()` against the actual claude binary to confirm CLAUDE-01, CLAUDE-02, and CLAUDE-03 are satisfied. This task makes NO code changes — it validates what Task 1 created.

**Validation sequence (run all, report each result):**

**Test 1 — CLAUDE-01: Env fix works (no CLAUDECODE error)**
```python
# Simulate what Agent Zero's Python runtime does:
import subprocess, os
env_with_claudecode = dict(os.environ, CLAUDECODE='1')
cmd = ['claude', '--print', '--output-format', 'json', 'say HELLO in one word']
r = subprocess.run(cmd, capture_output=True, text=True, env=env_with_claudecode, timeout=10)
# Expect: returncode != 0, stderr contains "Cannot be launched"
assert r.returncode != 0 and 'Cannot' in r.stderr, f"FAIL: expected error, got returncode={r.returncode}"
print('CLAUDE-01a PASS: CLAUDECODE=1 correctly triggers error')

# Now with env fix:
env_clean = {k: v for k, v in env_with_claudecode.items() if k != 'CLAUDECODE'}
r2 = subprocess.run(cmd, capture_output=True, text=True, env=env_clean, timeout=120)
assert r2.returncode == 0, f"FAIL: env fix did not work, exit={r2.returncode}, stderr={r2.stderr[:200]}"
print(f'CLAUDE-01b PASS: env fix works, returncode={r2.returncode}')
```

**Test 2 — CLAUDE-02 + CLAUDE-03: claude_single_turn returns clean text**
```python
import sys
sys.path.insert(0, '/Users/rgv250cc/Documents/Projects/agent-zero')
from python.helpers.claude_cli import claude_single_turn

response = claude_single_turn('Reply with only the word PONG.')
assert response, 'FAIL: empty response'
assert '\x1b' not in response, f'FAIL: ANSI sequences in response: {repr(response[:100])}'
assert '{' not in response or 'type' not in response, 'FAIL: JSON wrapper leaked into response'
print(f'CLAUDE-02+03 PASS: response = {repr(response)}')
```

**Test 3 — Error handling: returncode non-zero raises RuntimeError**
```python
import subprocess, os
from python.helpers.claude_cli import claude_single_turn
# Pass an invalid flag to trigger immediate claude error
env_clean = {k: v for k, v in os.environ.items() if k != 'CLAUDECODE'}
r = subprocess.run(['claude', '--invalid-flag-xyz'], capture_output=True, text=True, env=env_clean, timeout=10)
assert r.returncode != 0, 'FAIL: expected non-zero exit for invalid flag'
print(f'CLAUDE-03 error-path PASS: invalid flag → returncode={r.returncode}')
```

**Expected output from all three tests:**
```
CLAUDE-01a PASS: CLAUDECODE=1 correctly triggers error
CLAUDE-01b PASS: env fix works, returncode=0
CLAUDE-02+03 PASS: response = 'PONG'  (or similar)
CLAUDE-03 error-path PASS: invalid flag → returncode=1
```

Run each test block sequentially. Print results. If any assert fails, capture full error output and the exact response/stderr for diagnosis.

**Do NOT modify `claude_cli.py` based on test results** — if a test reveals an issue, diagnose and fix `claude_cli.py` before re-running. If the claude binary is not on PATH in the current shell context, try running with full path `/Users/rgv250cc/.local/bin/claude` in the test commands only (do NOT hardcode the full path in `claude_cli.py` itself — that would break portability).
  </action>
  <verify>
All three test assertions pass with no AssertionError. Output contains:
- "CLAUDE-01a PASS"
- "CLAUDE-01b PASS"
- "CLAUDE-02+03 PASS"
- "CLAUDE-03 error-path PASS"

Run: `cd /Users/rgv250cc/Documents/Projects/agent-zero && python3 -c "[paste test blocks sequentially]"`
  </verify>
  <done>
All four PASS lines printed. No AssertionError. `response` contains non-empty text with no ANSI escape sequences (no `\x1b` in repr). CLAUDE-01, CLAUDE-02, and CLAUDE-03 are empirically confirmed satisfied.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. File exists: `python/helpers/claude_cli.py`
2. Structure check passes (Task 1 verify command)
3. All four live test assertions pass (Task 2 verify command)
4. `repr(response)` from Test 2 shows clean text — no `\x1b`, no JSON keys
5. `returncode` from Test 1b is 0 (env fix works)
</verification>

<success_criteria>
Phase 8 plan 01 succeeds when:
- `python/helpers/claude_cli.py` exists with `claude_single_turn()` and `claude_single_turn_text()`
- CLAUDE-01 confirmed: env fix prevents "Cannot launch inside session" error
- CLAUDE-02 confirmed: `claude_single_turn()` returns complete response text
- CLAUDE-03 confirmed: response is ANSI-free; process exit detected via returncode
- All Task 2 assertions pass with live claude binary at claude 2.1.55
</success_criteria>

<output>
After completion, create `.planning/phases/08-claude-cli-single-turn-env-fix/08-01-SUMMARY.md`
</output>
