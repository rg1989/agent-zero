---
phase: 14-opencode-session-wrapper
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/helpers/opencode_cli.py
autonomous: true
requirements:
  - CLI-05

must_haves:
  truths:
    - "Skill code can call session.start(), session.send(prompt), session.exit() with no direct tmux subcommand calls"
    - "OpenCodeSession encodes the empirically verified Ctrl+P exit sequence — not /exit which triggers agent picker"
    - "OpenCodeSession uses OPENCODE_PROMPT_PATTERN imported from tmux_tool, not a re-declared copy"
    - "send() raises RuntimeError (not hang) when response timeout is exceeded; sends C-c to interrupt"
    - "send() raises RuntimeError if called before start()"
    - "OpenCodeSession.start() waits for OPENCODE_PROMPT_PATTERN before returning — startup not declared done until ready state confirmed"
  artifacts:
    - path: "python/helpers/opencode_cli.py"
      provides: "OpenCodeSession class with start/send/exit interface"
      min_lines: 80
      exports: ["OpenCodeSession"]
      contains: "OPENCODE_PROMPT_PATTERN"
  key_links:
    - from: "python/helpers/opencode_cli.py"
      to: "python/tools/tmux_tool.py"
      via: "import OPENCODE_PROMPT_PATTERN, OPENCODE_START_TIMEOUT, ANSI_RE"
      pattern: "from python\\.tools\\.tmux_tool import"
    - from: "python/helpers/opencode_cli.py OpenCodeSession.exit()"
      to: "tmux send-keys C-p sequence"
      via: "3-step Ctrl+P palette exit"
      pattern: "C-p"
    - from: "python/helpers/opencode_cli.py OpenCodeSession.send()"
      to: "_wait_ready"
      via: "prompt pattern polling loop"
      pattern: "_wait_ready.*OPENCODE_PROMPT_PATTERN"
---

<objective>
Create python/helpers/opencode_cli.py containing the OpenCodeSession class — a stateful wrapper around the Phase 13 tmux primitives that exposes a clean .start() / .send(prompt) / .exit() interface, mirroring the ClaudeSession pattern from python/helpers/claude_cli.py.

Purpose: Satisfies CLI-05. Skill code can orchestrate OpenCode sessions without any knowledge of tmux subcommands, ANSI stripping, or exit-sequence gotchas. All empirical Phase 13 findings are encoded in this class.

Output: python/helpers/opencode_cli.py — validated end-to-end against the installed OpenCode v1.2.14 binary in Docker.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference — the exact pattern to mirror
@python/helpers/claude_cli.py

# Source of OPENCODE_PROMPT_PATTERN, OPENCODE_START_TIMEOUT, ANSI_RE to import
@python/tools/tmux_tool.py

# Prior phase summary — Phase 13 empirical findings and exit sequence decision
@.planning/phases/13-interactive-cli-session-lifecycle/13-02-SUMMARY.md

# Research — full architecture spec and anti-patterns
@.planning/phases/14-opencode-session-wrapper/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement OpenCodeSession in python/helpers/opencode_cli.py</name>
  <files>python/helpers/opencode_cli.py</files>
  <action>
Create python/helpers/opencode_cli.py with the full OpenCodeSession class. Model the file structure directly on python/helpers/claude_cli.py: module docstring, imports, module-level constants, then the class.

**Imports and constants:**
```python
import subprocess
import re
import time

from python.tools.tmux_tool import OPENCODE_PROMPT_PATTERN, OPENCODE_START_TIMEOUT, ANSI_RE

_TMUX_SESSION = "shared"
_OPENCODE_RESPONSE_TIMEOUT = 120  # seconds — AI response budget
```

CRITICAL: If the import from python.tools.tmux_tool fails at runtime (wrong sys.path), verify with:
`python3 -c "import sys; sys.path.insert(0, '/a0'); from python.tools.tmux_tool import OPENCODE_PROMPT_PATTERN; print(OPENCODE_PROMPT_PATTERN)"`
If import fails, copy the three constants directly into opencode_cli.py with a comment: `# Copied from python/tools/tmux_tool.py — single source of truth is there`.

**Class: OpenCodeSession**

__init__(self, response_timeout: int = _OPENCODE_RESPONSE_TIMEOUT):
- self._running = False
- self._response_timeout = response_timeout

start(self) -> None:
- Send `export PATH=/root/.opencode/bin:$PATH && opencode /a0` + Enter via tmux send-keys
- Be defensive with PATH: include the export even if bashrc already sets it (no-op if already set)
- Add a 0.5s sleep after sending before _wait_ready — Phase 13 research pitfall 3: first prompt timing issue
- Call self._wait_ready(timeout=OPENCODE_START_TIMEOUT, prompt_pattern=OPENCODE_PROMPT_PATTERN)
- Set self._running = True
- Raises RuntimeError (propagated from _wait_ready) if OpenCode does not reach ready state

send(self, prompt: str) -> str:
- Guard: if not self._running: raise RuntimeError("OpenCodeSession not started — call start() first")
- Send prompt + Enter via tmux send-keys
- Call self._wait_ready(timeout=self._response_timeout, prompt_pattern=OPENCODE_PROMPT_PATTERN)
- After wait_ready, read full pane: subprocess.run(["tmux", "capture-pane", "-t", _TMUX_SESSION, "-p", "-S", "-300"], ...)
- Return ANSI_RE.sub("", result.stdout).rstrip()
- Note in docstring: returns full cleaned pane content (TUI chrome included); response text is visible in the content

exit(self) -> None:
- If not self._running: return (idempotent)
- CRITICAL — 3-step exit sequence (empirically verified Phase 13, must not be changed):
  Step 1: subprocess.run(["tmux", "send-keys", "-t", _TMUX_SESSION, "C-p"], ...)  # open commands palette
  Step 2: time.sleep(0.2)  # wait for palette to open
  Step 3: subprocess.run(["tmux", "send-keys", "-t", _TMUX_SESSION, "exit", "Enter"], ...)  # filter + execute
- Call self._wait_ready(timeout=15, prompt_pattern=r'[$#>%]\s*$')  # wait for shell return
- Set self._running = False
- DO NOT send "/exit" directly — the "/" character opens the AGENT PICKER in OpenCode v1.2.14,
  not a command prefix. This is the most critical gotcha from Phase 13 (13-02-SUMMARY.md).

_wait_ready(self, timeout: float, prompt_pattern: str) -> str:
- Synchronous translation of TmuxTool._wait_ready (remove asyncio.sleep, use time.sleep)
- prompt_re = re.compile(prompt_pattern)
- deadline = time.time() + timeout
- prev_content = None
- time.sleep(0.3)  # Phase 12 decision: initial delay prevents stale-prompt false positive
- Loop while time.time() < deadline:
  - result = subprocess.run(["tmux", "capture-pane", "-t", _TMUX_SESSION, "-p", "-S", "-50"], ...)
  - clean = ANSI_RE.sub("", result.stdout).rstrip()
  - lines = [l for l in clean.splitlines() if l.strip()]
  - Strategy 1: if lines and prompt_re.search(lines[-1]): return clean
  - Strategy 2: if prev_content is not None and clean == prev_content: return clean
  - prev_content = clean
  - time.sleep(0.5)
- On timeout: send C-c to interrupt, then raise RuntimeError with message including timeout value and Ollama hint

running property (bool): return self._running

**All subprocess.run calls:** use list-form (never shell=True), capture_output=True, text=True.

**Module docstring** should reference Phase 13 empirical basis and state the interface clearly.
  </action>
  <verify>
Run inside Docker container to verify import and class structure:
```
docker exec agent-zero python3 -c "
import sys
sys.path.insert(0, '/a0')
from python.helpers.opencode_cli import OpenCodeSession
s = OpenCodeSession()
print('class loaded OK')
print('running before start:', s.running)
"
```
Expected output: `class loaded OK` and `running before start: False` with no import errors.

Also verify the import of constants works:
```
docker exec agent-zero python3 -c "
import sys; sys.path.insert(0, '/a0')
from python.tools.tmux_tool import OPENCODE_PROMPT_PATTERN, OPENCODE_START_TIMEOUT, ANSI_RE
print('OPENCODE_PROMPT_PATTERN:', repr(OPENCODE_PROMPT_PATTERN))
print('OPENCODE_START_TIMEOUT:', OPENCODE_START_TIMEOUT)
"
```
  </verify>
  <done>
python/helpers/opencode_cli.py exists with OpenCodeSession class. Class imports cleanly inside Docker with sys.path.insert(0, '/a0'). OPENCODE_PROMPT_PATTERN sourced from tmux_tool (not redeclared). All four methods present: start(), send(), exit(), _wait_ready(). running property returns False before start().
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end validation against installed OpenCode v1.2.14 in Docker</name>
  <files>python/helpers/opencode_cli.py</files>
  <action>
Run the full validation test inside the Docker container to verify all three CLI-05 success criteria.

**Validation script** — run via docker exec:
```python
import sys
sys.path.insert(0, '/a0')
from python.helpers.opencode_cli import OpenCodeSession

session = OpenCodeSession(response_timeout=60)

# CLI-05 criterion 1: clean interface — no direct tmux calls in this skill code
session.start()
print("started:", session.running)  # must be True

# CLI-05 criterion 2: empirically verified patterns applied correctly
response = session.send("What is 2+2? Reply with just the number.")
print("response length:", len(response))
print("response snippet:", response[:300])
assert "4" in response, f"Expected '4' in response, got: {response[:200]}"

# Multi-turn: session context persists
response2 = session.send("Add 1 to the number you just said. Reply with just the result.")
print("response2 snippet:", response2[:200])
assert "5" in response2, f"Expected '5' in response2, got: {response2[:200]}"

session.exit()
print("exited:", not session.running)  # must be True

print("PASS — CLI-05 validated")
```

Execute via:
```bash
docker exec agent-zero python3 -c "$(cat <<'PYEOF'
[paste script above]
PYEOF
)"
```

Or write the script to a temp file and exec it:
```bash
docker cp /tmp/validate_opencode.py agent-zero:/tmp/validate_opencode.py
docker exec agent-zero python3 /tmp/validate_opencode.py
```

**If validation reveals issues**, fix in opencode_cli.py before marking done:
- If import fails: copy constants directly into opencode_cli.py with source comment
- If start() times out: check that the PATH export is included in the start command
- If send() response assertion fails: print response[:500] to inspect TUI chrome, adjust if needed
- If exit() hangs: verify the C-p sequence is working (check for "esc interrupt" in pane after send)
- If first send() after start() doesn't receive response: add 0.5s sleep in start() before _wait_ready completes, or add sleep in send() on first call

**CLI-05 criterion 3 (hang regression guard):** Verify the RuntimeError path works:
```bash
docker exec agent-zero python3 -c "
import sys
sys.path.insert(0, '/a0')
from python.helpers.opencode_cli import OpenCodeSession
s = OpenCodeSession()
try:
    s.send('test')  # before start()
    print('FAIL — should have raised')
except RuntimeError as e:
    print('PASS — guard works:', e)
"
```
Expected: `PASS — guard works: OpenCodeSession not started — call start() first`
  </action>
  <verify>
```bash
# Full end-to-end test
docker exec agent-zero python3 /tmp/validate_opencode.py
# Expected: "PASS — CLI-05 validated" as last output line

# Guard test
docker exec agent-zero python3 -c "
import sys; sys.path.insert(0, '/a0')
from python.helpers.opencode_cli import OpenCodeSession
s = OpenCodeSession()
try: s.send('x')
except RuntimeError as e: print('guard OK:', e)
"
# Expected: "guard OK: OpenCodeSession not started — call start() first"
```
  </verify>
  <done>
Full validation test completes with "PASS — CLI-05 validated". Multi-turn (two consecutive send() calls) both return expected numeric results. session.running is True after start(), False after exit(). Pre-start guard raises RuntimeError correctly. All three CLI-05 success criteria observable in output.
  </done>
</task>

</tasks>

<verification>
1. python/helpers/opencode_cli.py exists and has OpenCodeSession class with start(), send(), exit(), _wait_ready(), running property
2. Class imports cleanly inside Docker: `docker exec agent-zero python3 -c "import sys; sys.path.insert(0, '/a0'); from python.helpers.opencode_cli import OpenCodeSession; print('OK')"`
3. OPENCODE_PROMPT_PATTERN is imported from python.tools.tmux_tool (not re-declared): `grep "from python.tools.tmux_tool import" python/helpers/opencode_cli.py`
4. Exit method uses C-p sequence: `grep "C-p" python/helpers/opencode_cli.py` returns match
5. No shell=True anywhere: `grep "shell=True" python/helpers/opencode_cli.py` returns empty
6. End-to-end validation passes: start() → send() → send() → exit() all succeed against live OpenCode v1.2.14
</verification>

<success_criteria>
- OpenCodeSession class exists in python/helpers/opencode_cli.py
- Class loads inside Docker with no import errors
- .start() sends `opencode /a0` to tmux and waits for OPENCODE_PROMPT_PATTERN — does not return until ready state confirmed
- .send(prompt) returns cleaned pane content after response — never hangs beyond response_timeout
- .exit() uses Ctrl+P palette sequence (not /exit) and waits for shell prompt return
- Multi-turn: two consecutive .send() calls both succeed and return coherent responses
- .running reflects correct state at each lifecycle stage
- CLI-05 requirement satisfied: skill code orchestrates full OpenCode lifecycle without any direct tmux knowledge
</success_criteria>

<output>
After completion, create `.planning/phases/14-opencode-session-wrapper/14-01-SUMMARY.md`
</output>
